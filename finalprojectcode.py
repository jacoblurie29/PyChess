# -*- coding: utf-8 -*-
"""FinalProjectCode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-BRCS8ay2xqbqlzd2LfYjdsmzTytZVyR

#The Game of Chess

The modern game of chess has been around for over 600 years. It involves two players moving sets of pieces to capture their opponent's pieces leading to victory.

Each player has the following pieces:


*   1 King
*   1 Queen
*   2 Rooks
*   2 Bishops
*   2 Knights
*   8 Pawns

The object of the game is to put the other player in "checkmate". When a piece is in a position to capture the other opponent's king, the other player is considered "in-check". When there are no moves to remove that player from check, this is considered checkmate and the game is over.

#Development of The Game in Python
The chessboard object contains 2D array of piece objects that contain at least a current position, player-owner, and marker. The board will also contains information about each player and the ability to print the board both ways. "X" values will be the letter and "Y" values will be the number. A traditional chessboard is an 8 x 8 square matrix.

The board will be able to move it's pieces through commands that choose the current position of the piece and where it should go. From there, if a valid piece is selected, a move set will be created of all possible moves for that piece in which the new move is validated and executed.

Empty spots on the board will contain identifying values so that they can be treated as empty spaces.

#Check and Checkmate
Check and checkmate are extremely complex and will require the board to searched for all possible moves from the player who is IN check. This was why I choose to assess movability using move sets. These sets will be lists that will contain every possible move for a piece. For check, make all of the movesets for every piece of the opposing players pieces and if at least one move set contains the current position of the player's king, then that player is in check. Therefore to assess checkmate, the player must be in check, every move set must be created, then every move must be executed and if no moves cause a scenario in which the player in check is no longer in check, then the game is over.

#Gameplay
The board will printed using ASCII text. Since the font used in Google Colab is a monospace font, the board can be printed easily. The board will display the player's names as well as the position matrix and all positions of the current pieces on the board. Also availible will be every captured piece by each player. 

There will be an option to undo the previous move as well. This will be done using the stack data structure. Each time a player move is executed, the previous state of the board will be deep copied and pushed into the stack. Upon the undo being called, the previous board state will be popped from the stack and replace the current state of the board.

It is important that in this undo action, the board is deep copied. In python, attempting to copy using the '=' operator will only copy the reference of the board object, thus a copy will not actually be created and past states could not be saved. We can use the 'import copy' to add python functions for deep copying.

#Input Validation
It is important that inputs are correct when the players request moves. The easiest way to do this is using regular expressions. Thus, we can check if the input follows the format [letter][number]. We can use the 'import re' to add the python functions for regular expressions. It also to be confirmed that the selected piece is owned by the player making the move. Upon the input being validated, the move can then be executed.

#Display
                Player 1

       8  |  R N B Q K B N R
       7  |  P P P P P P P P
       6  |  - - - - - - - -    Player 1 Captured Pieces:
       5  |  - - - - - - - -
       4  |  - - - - - - - -
       3  |  - - - - - - - -    Player 2 Captured Pieces:
       2  |  p p p p p p p p
       1  |  r n b q k b n r
             _______________
             a b c d e f g h

                Player 2
"""

# I'm going to attempt to fully implement a chess game
# This includes movement of pieces, capturing of pieces, check, checkmate, undoing moves, etc.
# Everything is heavily commented because I am doing this completely from scratch and my knowledge of chess

# !!! TESTER SECTION IS AT BOTTOM OF NOTEBOOK !!!

# RegEx import for input validation
import re

# copy import so we can deep copy the table for checkmate validation
import copy

# system exit import for closing the program
import sys

# Chessboard object contains 2D array of piece objects that contain at least a current position, player-owner, and marker.
# Board also contains information about each player and the ability to print the board both ways.
# "X" values will be the letter and "Y" values will be the number.
#
# Board layout:
#
#              Player1
#       8
#       7
#       6
#       5
#       4
#       3
#       2
#       1
#          a b c d e f g h
#
#              Player2
#
#   The indicies of positions will have to be decremented by 1 because chess boards start at one not zero.
#   Also due to the nature of python lists and the typical verbal format of chess locations,
#   the input from a user will have to flipped when indexing the array
#       
#               i.e. the position "B5" would be at board[4][1]

# One player will have lowercase pieces, the other will have uppercase pieces

# NOTE: values such as "newX", "oldX", "newY", "oldY" are THE ARRAY INDICIES
#       These values are 0 - 7 not 1 - 8


# Initial thoughts on check and checkmate algorithm:

#   Check and checkmate are extremely complex and will require the board to searched
#   for all possible moves from the player who is IN check.

#   This was why I choose to assess movability using move sets. These sets will be lists
#   that will contain every possible move for a piece. Therefore to assess
#   checkmate, the player must be in check, every move set must be created, then
#   every move must be exectued and if no moves cause a scenario in which the player in
#   check is no longer in check, then the game is over.

#   For check it is simpler. Make all of the movesets for every piece of the 
#   opposing players pieces and if at least one move set contains the current
#   position of the player's king, then that player is in check.




# Last Updated: 4/4/2022 6:37 PM
# TODO: En Passant
# TODO: Castling



# Chess board 
class ChessBoard():
    def __init__(board, player1, player2):
        board.player1 = player1
        board.player2 = player2
        # 2D array of piece objects (initial state of b)
        board.piecesArray = [[Rook("A1", 2), Knight("B1", 2), Bishop("C1", 2), Queen("D1", 2), King("E1", 2), Bishop("F1", 2), Knight("G1", 2), Rook("H1", 2)],\
                            [Pawn("A2", 2), Pawn("B2", 2), Pawn("C2", 2), Pawn("D2", 2), Pawn("E2", 2), Pawn("F2", 2), Pawn("G2", 2), Pawn("H2", 2)],\
                            [Empty("A3"), Empty("B3"), Empty("C3"), Empty("D3"), Empty("E3"), Empty("F3"), Empty("G3"), Empty("H3")],\
                            [Empty("A4"), Empty("B4"), Empty("C4"), Empty("D4"), Empty("E4"), Empty("F4"), Empty("G4"), Empty("H4")],\
                            [Empty("A5"), Empty("B5"), Empty("C5"), Empty("D5"), Empty("E5"), Empty("F5"), Empty("G5"), Empty("H5")],\
                            [Empty("A6"), Empty("B6"), Empty("C6"), Empty("D6"), Empty("E6"), Empty("F6"), Empty("G6"), Empty("H6")],\
                            [Pawn("A7", 1), Pawn("B7", 1), Pawn("C7", 1), Pawn("D7", 1), Pawn("E7", 1), Pawn("F7", 1), Pawn("G7", 1), Pawn("H7", 1)],\
                            [Rook("A8", 1), Knight("B8", 1), Bishop("C8", 1), Queen("D8", 1), King("E8", 1), Bishop("F8", 1), Knight("G8", 1), Rook("H8", 1)]]

        # Lists hold the pieces lost by a player by the other team
        board.player1LostPieces = []
        board.player2LostPieces = []

        # allows the game to be finished
        board.isFinished = False

        # Stacks hold the previous board states so that players can call an undo function in case of a mistake
        # Undo function will a pop command from the stack that will replace the current state of the board
        board.previousMoves = Stack()



    # Moves a piece to any location on the board, updates it's position, and replaces old location with an empty
    def movePieceToNewPosition(board, oldX, newX, oldY, newY):

        # if-statements to collect pieces taken by opposing player
        
        if board.piecesArray[newX][newY].marker != "-":
            # if player 1 takes a piece from player 2: 
            if board.piecesArray[newX][newY].player == 2 and board.piecesArray[oldX][oldY].player == 1:
                board.player2LostPieces.append(board.piecesArray[newX][newY])
            # if player 2 takes a piece from player 1:
            else:
                board.player1LostPieces.append(board.piecesArray[newX][newY])

        if board.piecesArray[newX][newY].marker.upper() != 'K':
            # moves old piece to new place 
            oldPosition = board.piecesArray[oldX][oldY].position;
            board.piecesArray[newX][newY] = board.piecesArray[oldX][oldY]
            board.piecesArray[newX][newY].position = indexToLetter(newY + 1) + str(newX + 1)

            # creates empty object in old location
            board.piecesArray[oldX][oldY] = Empty(oldPosition);

            # in the case of a pawn, ensures that after any move it is no longer able to move 2 spaces
            if board.piecesArray[newX][newY].marker == "p" or board.piecesArray[newX][newY].marker == "P":
                board.piecesArray[newX][newY].alreadyMoved = True

        # for debugging
        # print("NEW LOCATION: " + board.piecesArray[newX][newY].position)

    # Input from a player to request a move of a piece to a new location
    def playerMove(board, oldPosition, newPosition):


        # set the array indicies of old and new positions
        oldX = int(oldPosition[1]) - 1
        oldY = int(letterToIndex(oldPosition[0])) - 1
        newX = int(newPosition[1]) - 1
        newY = int(letterToIndex(newPosition[0])) - 1

        # check if move can be completed and complete move
        moveSet = board.piecesArray[oldX][oldY].generateMoveSet(oldPosition, board, False)

        # checks if new position is in moveset and moves piece if it is
        if newPosition in moveSet:
            board.movePieceToNewPosition(oldX, newX, oldY, newY)
        else:
            raise Exception('That piece can not be moved there!')

    
    # DETAIL OF THE CHECK PROCESS (needed to rewrite for debugging purposes):
    #
    # Lets say player 1 puts player 2 in check
    #
    # This is found by finding every one of player 1's pieces, finding their move sets
    # and if the location of player 2's king is one of the move sets, the player is in check
    #
    # Now we have to check for checkmate
    #
    # Now find the move sets of every one of player 2's pieces. Execute each move on a deep copied table
    # On each deep copied table, check for player 2 being in check
    # If in any case, there is a move on a deep copied table that leads to a no-check scenario for player 2
    # that means this is not checkmate.

    def isInCheck(board, player, checkmateCheck):
        # NOTES:
        # To assess check, find the location of a player's king. Next, collect all
        # pieces of the other player and calculate their move set.
        # If the location of the opposing king is in those move sets, the player is in check.

        # For this algorithm, the player inputted in the method will be the player
        # who is being assessed to BE IN CHECK OR NOT

        locationOfKing = ""

        # finds location of the king piece
        for y in board.piecesArray:
            for xy in y:
                if xy.marker.upper() == 'K' and xy.player == player:
                    locationOfKing = xy.position

        # checks for check and then if in check, checks for checkmate
        for y in board.piecesArray:
            for xy in y:
                if xy.player != player and xy.player != 0:
                    moveSet = xy.generateMoveSet(xy.position, board, False)
                    if locationOfKing in moveSet:
                        # WE ARE IN CHECK HERE

                        checkMate = "NO_CHECKMATE"

                        if checkmateCheck == True:
                            checkMate = board.isCheckmate(player, locationOfKing)

                        if checkMate == "CHECKMATE":
                            return "CHECKMATE"
                        else:
                            return "CHECK"
                            
        return "NO_CHECK"

    
    def isCheckmate(board, player, locationOfKing):
        # To decide checkmate, parse through every piece of the player who is 
        # CURRENTLY IN CHECK. Calculate those movesets and create new boards with those
        # moves executed. If any of those moves take the king OUT OF CHECK then it is
        # NOT checkmate. If there are no such cases, the game is over.

        # parse through every board position
        for y in board.piecesArray:
            for xy in y:

                # only for pieces of the other team
                if xy.player == player and xy.player != 0:

                    # creates move set for that piece
                    moveSet = xy.generateMoveSet(xy.position, board, False)

                    #parse through move set
                    for move in moveSet:
                        
                        # creates deep copy of board
                        tempBoard = copy.deepcopy(board)

                        # moves piece to proposed location
                        tempBoard.playerMove(xy.position, move)

                        # SEAtempBoard.diagnostic()

                        # checks if tempBoard is not still in check after the move
                        if tempBoard.isInCheck(xy.player, False) == "NO_CHECK":

                            # prints a diagnostic and states the game is not over
                            board.isFinished = False
                            return "NO_CHECKMATE"
        
        # if you get to here, none of the moves took the player out of check and the game is over
        board.isFinished = True
        return "CHECKMATE"

                        
 

    # Prints board in either orientation, this will ONLY work if the IDE font is monospaced
    def printBoard(board, player):
        print("\n\n-----------------------------\n")
        
        # orientation 1
        if player == 1:
            print("               " + board.player2 + "\n")
            i = 1
            for x in board.piecesArray:
                print(str(i) + "  |   ", end='')
                for y in x:
                    print(y.marker + "  ", end = '')

                # print player 1 gained pieces
                if i == 3:
                    print("    " + board.player2 + "'s captured pieces: ", end='')
                    for x in board.player1LostPieces:
                        print(x.marker + " ", end='')

                # print player 2 gained pieces
                if i == 6:
                    print("    " + board.player1 + "'s captured pieces: ", end='')
                    for x in board.player2LostPieces:
                        print(x.marker + " ", end='')
                print("\n")
                i += 1
            print("       ___________________")        
            print("       a  b  c  d  e  f  g  h\n")
            print("               " + board.player1 + "\n")
        # orientation 2
        else: 
            print("               " + board.player1 + "\n")
            i = 8
            for x in reversed(board.piecesArray):
                print(str(i) + "  |   ", end='')
                for y in reversed(x):
                    print(y.marker + "  ", end = '')
                
                # print player 1 gained pieces
                if i == 3:
                    print("    " + board.player1 + "'s captured pieces: ", end='')
                    for x in board.player1LostPieces:
                        print(x.marker + " ", end='')

                # print player 2 gained pieces
                if i == 6:
                    print("    " + board.player2 + "'s captured pieces: ", end='')
                    for x in board.player2LostPieces:
                        print(x.marker + " ", end='')

                print("\n")
                i -= 1
            print("       ______________________")        
            print("       h  g  f  e  d  c  b  a\n")
            print("\n               " + board.player2)
        
        print("-----------------------------\n")
        
    # for debugging. prints less asthetic, data-driven representation of board state
    def diagnostic(board):
        i = 1
        for x in board.piecesArray:
            print("ROW: " + str(i))
            for y in x:
                print(y.marker + " " + y.position + "  |||  ", end = '')
            print("\n")
            i += 1
        print("END MOVE.\n\n\n")




# Pawn piece
class Pawn():
    def __init__(pawn, position, player):
        pawn.position = position
        
        if player == 1:
            pawn.marker = "P"
        else:
            pawn.marker = "p"
            
        pawn.alreadyMoved = False
        pawn.player = player

    # Generate a list of all possible moves the pawn piece can make
    def generateMoveSet(pawn, currentPosition, board, printL):
        setList = []
        
        # PAWN NOTES:
        #
        # will have to test the canMove method on all surrounding 1-length moves and vertical two length moves.
        #
        #   All potential moves (X):
        # 
        #           X 
        #         X X X
        #           P
        #         X X X
        #           X 
        #
        #    (oldX, oldY - 2), (oldX, oldY + 2) 
        #    (oldX - 1, oldY - 1),(oldX, oldY - 1),(oldX + 1, oldY - 1)
        #    (oldX - 1, oldY + 1),(oldX, oldY + 1),(oldX + 1, oldY + 1)
        #
        # Steps: Generate [letter][number] combos of above relations
        #        Test each with canMove function
        #        Append true results to setList
        #
        # Still not sure if I should parse through locations hardcoded individually or by math
        #    since there is only 8 of them in contrary to let's say a queen which I would
        #    would have to use a loop due to the ray-nature of it's movement.
        #    Naive way of doing this would be to simply parse through all 64 locations (1-8, a-h).
        #    I will start with the naive way before refining the space of tested locations

        # For a pawn move to be legal:
        # Pawn can move forward once or if it is it's intial position can move forward two 
        # Pawn can not move forward if ANY piece is there
        # Pawns can only move in the direction alloted away from that player
        # Pawn can move slanted if occupying piece is of the other player

        # In the context of the board for moves, we will say that player1 defaults from the south side
        # and player2 from the north side. Therefore, player1's pieces can only move
        # if the number in the piece position is increasing and vice versa for player2.


        # naively test each location on the board to see if the pawn can move there
        # Essentially contains movement rule set
        for y in board.piecesArray:
            for xy in y:
                newY = int(xy.position[1]) - 1
                newX = int(letterToIndex(xy.position[0])) - 1

        
                # displacement of piece in x and y directions
                xMove = int(letterToIndex(xy.position[0])) - int(letterToIndex(currentPosition[0]))
                yMove = int(xy.position[1]) - int(currentPosition[1])

                # check if player 1 (y displacement must be negative)
                if pawn.player == 1:              

                    # case in which pawn has never been moved and wants to move two
                    # also checks for collision if the move is 2 spaces 
                    if yMove == -2 and xMove == 0 and pawn.alreadyMoved == False and board.piecesArray[newY + 1][newX].marker == '-':
                        # Check if there exists a piece there
                        if board.piecesArray[newY][newX].marker == "-":
                            # Now move the piece in the board   
                            setList.append(board.piecesArray[newY][newX].position)
                    # normal one square move request
                    elif yMove == -1 and xMove in [-1, 0, 1]:
                        # Check if there exists a piece there and if the move is straight
                        if board.piecesArray[newY][newX].marker == "-" and xMove == 0:
                            # Now move the piece in the board
                            setList.append(board.piecesArray[newY][newX].position)
                        # Check if there exists a piece there and if the move is slanted
                        elif board.piecesArray[newY][newX].marker != "-" and xMove != 0 and board.piecesArray[newY][newX].player == 2:
                            # Now move the piece in the board
                            setList.append(board.piecesArray[newY][newX].position)
                # else it is player 2 (y displacement must be positive)
                else:
                    # case in which pawn has never been moved and wants to move two
                    # still need to add a collision condition (can't move two if there is one in between)
                    if yMove == 2 and xMove == 0 and pawn.alreadyMoved == False and board.piecesArray[newY - 1][newX].marker == '-':
                        # Check if there exists a piece there
                        if board.piecesArray[newY][newX].marker == "-":
                            # Now move the piece in the board   
                            setList.append(board.piecesArray[newY][newX].position)
                    # normal one square move request
                    elif yMove == 1 and xMove in [-1, 0, 1]:
                        # Check if there exists a piece there and if move is straight
                        if board.piecesArray[newY][newX].marker == "-" and xMove == 0:
                            # Now move the piece in the board
                            setList.append(board.piecesArray[newY][newX].position)
                        # Check if there exists a piece there and if move is slanted
                        elif board.piecesArray[newY][newX].marker != "-" and xMove != 0 and board.piecesArray[newY][newX].player == 1:
                            # Now move the piece in the board
                            setList.append(board.piecesArray[newY][newX].position)

        
        # print and return the result (if the user wants it to be printed)
        if printL == True:
            print("Move set for pawn at " + currentPosition + ": " + printList(setList)) 

        return setList   
        

class Rook():
    def __init__(rook, position, player):
        rook.position = position
        rook.player = player

        if player == 1:
            rook.marker = "R"
        else:
            rook.marker = "r"

    def generateMoveSet(rook, currentPosition, board, printL):
        
        # ROOK NOTES:
        #
        # All possible moves
        #
        #         ^
        #         X
        #         X
        #   > X X R X X >
        #         X
        #         X
        #         ^
        #

        # Rooks moves linearly, any distance to the end of the board, as long
        # as the path that they take is either perfectly vertical or horizontal
        # and if there is nothing in the way in the path to the selected spot

        # This can be accomplished by comparing the X and Y values of the proposed
        # move to the original position. In a valid move, only ONE of the X and Y
        # value can change. 

        # i.e. if X changes from 2 to 6, Y must remain 3
        # or if Y changes from 5 to 2, X must remain 7

        # to create the move set, we will first create all the possible moves
        # by parsing through all common X values and all common Y values until a
        # collision is detected. If a collision is with a piece that is owned by the moving player,
        # that position is NOT included from the move set. If a collision is with a piece
        # from the other team, it IS included in the move set because it can be taken.

        setList = []
        
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test up from piece
        while iterableY <= 6:
            iterableY += 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if rook.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
        

        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test down from piece
        while iterableY >= 1:
            iterableY -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':
                if rook.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break
            else: 
                setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test left from piece
        while iterableX <= 6:
            iterableX += 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if rook.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test right from piece
        while iterableX >= 1:
            iterableX -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if rook.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            

    
        # print and return the result (if the user wants it to be printed)
        if printL == True:
            print("Move set for rook at " + currentPosition + ": " + printList(setList)) 

        return setList   


class Bishop():
    def __init__(bishop, position, player):
        bishop.position = position
        bishop.player = player

        if player == 1:
            bishop.marker = "B"
        else:
            bishop.marker = "b"

    def generateMoveSet(bishop, currentPosition, board, printL):
        
        # BISHOP NOTES:
        #
        # All possible moves
        #
        #   <           >
        #     X       X
        #       X   X
        #         B 
        #       X   X
        #     X       X        
        #   <           >
        #

        # Rooks moves linearly, any distance to the end of the board, as long
        # as the path that they take has a slope of 1 or -1 (it moves slanted)
        # and if there is nothing in the way in the path to the selected spot

        # This can be accomplished by comparing the X and Y values of the proposed
        # move to the original position. In a valid move, BOTH of the X and Y
        # value can change, incremented by +/- 1

        # i.e. if X changes from 2 to 6, Y must go from 3 to 7
        # or if Y changes from 4 to 2, X must go from 3 to 5 OR 3 to 2

        # to create the move set, we will first create all the possible moves
        # by parsing through all calculated X and Y values until a
        # collision is detected. If a collision is with a piece that is owned by the moving player,
        # that position is NOT included from the move set. If a collision is with a piece
        # from the other team, it IS included in the move set because it can be taken.
        # This collision technique is the same as the rook and will also be the same for the queen.

        setList = []
        
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test up-right from piece
        while iterableY <= 6 and iterableX <= 6:
            iterableY += 1
            iterableX += 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if bishop.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
        

        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test up-left from piece
        while iterableY <= 6 and iterableX >= 1:
            iterableY += 1
            iterableX -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':
                if bishop.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break
            else: 
                setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test down-right from piece
        while iterableX <= 6 and iterableY >= 1:
            iterableX += 1
            iterableY -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if bishop.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test down-left from piece
        while iterableX >= 1 and iterableY >= 1:
            iterableX -= 1
            iterableY -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if bishop.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            

    
        # print and return the result (if the user wants it to be printed)
        if printL == True:
            print("Move set for bishop at " + currentPosition + ": " + printList(setList)) 

        return setList  

    
class Queen():
    def __init__(queen, position, player):
        queen.position = position
        queen.player = player

        if player == 1:
            queen.marker = "Q"
        else:
            queen.marker = "q"

    
    def generateMoveSet(queen, currentPosition, board, printL):
        
        # Queen NOTES:
        #
        # All possible moves
        #         ^
        #   <     X     >
        #     X   X   X
        #       X X X
        # < X X X B X X X >
        #       X X X
        #     X   X   X        
        #   <     X     >
        #         ^

        # Queens moves linearly, any distance to the end of the board, as long
        # as the path that they take has a slope of 1 or -1 (it moves slanted) or
        # the X OR Y value remains constant through the move and if there is 
        # nothing in the way in the path to the selected spot

        # THE QUEEN IS A PERFECT COMBINATION OF THE BISHOP AND ROOK

        # This can be accomplished by comparing the X and Y values of the proposed
        # move to the original position. In a valid move, BOTH of the X and Y
        # value can change, incremented by +/- 1 or the X OR Y remains constant

        # i.e. if X changes from 2 to 6, Y can go from 3 to 7
        # or if Y changes from 4 to 2, X can go from 3 to 5 OR remain 3

        # to create the move set, we will first create all the possible moves
        # by parsing through all calculated X and Y values until a
        # collision is detected. If a collision is with a piece that is owned by the moving player,
        # that position is NOT included from the move set. If a collision is with a piece
        # from the other team, it IS included in the move set because it can be taken.
        # This collision technique is the same as the rook and will also be the same for the queen.

        # To code this I will simply copy and paste the existing rule sets from 
        # the bishop and the rook object

        setList = []
        
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test up-right from piece
        while iterableY <= 6 and iterableX <= 6:
            iterableY += 1
            iterableX += 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
        

        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test up-left from piece
        while iterableY <= 6 and iterableX >= 1:
            iterableY += 1
            iterableX -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':
                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break
            else: 
                setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test down-right from piece
        while iterableX <= 6 and iterableY >= 1:
            iterableX += 1
            iterableY -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test down-left from piece
        while iterableX >= 1 and iterableY >= 1:
            iterableX -= 1
            iterableY -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            

        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test up from piece
        while iterableY <= 6:
            iterableY += 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
        

        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test down from piece
        while iterableY >= 1:
            iterableY -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':
                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break
            else: 
                setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test left from piece
        while iterableX <= 6:
            iterableX += 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            
        iterableY = int(currentPosition[1]) - 1
        iterableX = int(letterToIndex(currentPosition[0])) - 1

        # test right from piece
        while iterableX >= 1:
            iterableX -= 1
            if board.piecesArray[iterableY][iterableX].marker != '-':

                if queen.player != board.piecesArray[iterableY][iterableX].player:
                    setList.append(board.piecesArray[iterableY][iterableX].position)
                
                break

            setList.append(board.piecesArray[iterableY][iterableX].position)
            

    
        # print and return the result (if the user wants it to be printed)
        if printL == True:
            print("Move set for queen at " + currentPosition + ": " + printList(setList)) 

        return setList  


class Knight():
    def __init__(knight, position, player):
        knight.position = position
        knight.player = player

        if player == 1:
            knight.marker = "N"
        else:
            knight.marker = "n"

    def generateMoveSet(knight, currentPosition, board, printL):
        
        # Knight NOTES:
        #
        # All possible moves
        #
        #       X - X
        #         -
        #   X     -     X
        #   - - - N - - -
        #   X     -     X
        #         -
        #       X - X
        #
        #

        # The knight does not move linearly, it can take all first degree positions with a slope
        # from it's current position of 3, -3, 1/3, and -1/3.

        # There are mathematical ways to figure this out but it seems easier to simply
        # hardcode in the 8 possible locations similar to how the pawn was done

        # All possible moves: (1,3),(3,1),(-1,3),(-3,1),(1,-3),(3,-1),(-1,-3),(-3,-1)

        # i.e. if X changes from 2 to 5, Y can go from 3 to 4 or 3 to 2
        # or if Y changes from 4 to 1, X can go from 5 to 6 OR 5 to 4

        # collisions are simpler with the knight. If there is a piece in the 
        # proposed position, the move cannot happen unless that piece is of the
        # the other player


        setList = []
        
        oldY = int(currentPosition[1]) - 1
        oldX = int(letterToIndex(currentPosition[0])) - 1

        # (1,3)
        if oldX + 1 <= 7 and oldY + 3 <= 7:

            newX = oldX + 1
            newY = oldY + 3

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (3,1)
        if oldX + 3 <= 7 and oldY + 1 <= 7:

            newX = oldX + 3
            newY = oldY + 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (-1,3)
        if oldX - 1 >= 0 and oldY + 3 <= 7:

            newX = oldX - 1
            newY = oldY + 3

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (-3,1)
        if oldX - 3 >= 0 and oldY + 1 <= 7:

            newX = oldX - 3
            newY = oldY + 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (1,-3)
        if oldX + 1 <= 7 and oldY - 3 >= 0:

            newX = oldX + 1
            newY = oldY - 3

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (3,-1)
        if oldX + 3 <= 7 and oldY - 1 >= 0:

            newX = oldX + 3
            newY = oldY - 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (-1,-3)
        if oldX - 1 >= 0 and oldY - 3 >= 0:

            newX = oldX - 1
            newY = oldY - 3

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (-3,-1)
        if oldX - 3 >= 0 and oldY - 1 >= 0:

            newX = oldX - 3
            newY = oldY - 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != knight.player:
                setList.append(board.piecesArray[newY][newX].position)

        
    
        # print and return the result (if the user wants it to be printed)
        if printL == True:
            print("Move set for knight at " + currentPosition + ": " + printList(setList)) 

        return setList  



class King():
    def __init__(king, position, player):
        king.position = position
        king.player = player

        if player == 1:
            king.marker = "K"
        else:
            king.marker = "k"


    def generateMoveSet(king, currentPosition, board, printL):
        
        # King NOTES:
        #
        # All possible moves
        #
        #            
        #         X X X
        #         X K X
        #         X X X
        #            
        #
        #

        # The king can simply move one square in any direction for a total of 8 possible places

        # There are mathematical ways to figure this out but it seems easier to simply
        # hardcode in the 8 possible locations similar to how the pawn was done

        # All possible moves: !(1,0),!(1,1),!(1,-1),!(0,1),!(0,-1),!(-1,0),!(-1,1),!(-1,-1)


        # collisions are simpler with the king. If there is a piece in the 
        # proposed position, the move cannot happen unless that piece is of the
        # the other player

        setList = []
        
        oldY = int(currentPosition[1]) - 1
        oldX = int(letterToIndex(currentPosition[0])) - 1

        # (1,1)
        if oldX + 1 <= 7 and oldY + 1 <= 7:

            newX = oldX + 1
            newY = oldY + 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (0,1)
        if oldY + 1 <= 7:
            
            newX = oldX
            newY = oldY + 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (-1,1)
        if oldX - 1 >= 0 and oldY + 1 <= 7:

            newX = oldX - 1
            newY = oldY + 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (-1,0)
        if oldX - 1 >= 0:

            newX = oldX - 1
            newY = oldY

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (1,-1)
        if oldX + 1 <= 7 and oldY - 1 >= 0:

            newX = oldX + 1
            newY = oldY - 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (0,-1)
        if oldY - 1 >= 0:

            newX = oldX
            newY = oldY - 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (1,0)
        if oldX + 1 <= 7:

            newX = oldX + 1
            newY = oldY

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        # (-1,-1)
        if oldX - 1 >= 0 and oldY - 1 >= 0:

            newX = oldX - 1
            newY = oldY - 1

            if board.piecesArray[newY][newX].marker == '-':
                setList.append(board.piecesArray[newY][newX].position)
            elif board.piecesArray[newY][newX].marker != '-' and board.piecesArray[newY][newX].player != king.player:
                setList.append(board.piecesArray[newY][newX].position)

        
    
        # print and return the result (if the user wants it to be printed)
        if printL == True:
            print("Move set for king at " + currentPosition + ": " + printList(setList)) 

        return setList  


# Empty class holds default attributes for places on board where there is no piece
class Empty():
    def __init__(empty, position):
        empty.position = position
        empty.marker = "-"   
        empty.player = 0


# Below methods are helper methods

# Converts chess position letter from ASCII to a number position
def letterToIndex(letter):
    return ord(letter.upper()) - 64

# Converts chess position number to ASCII letter
def indexToLetter(index):
    return chr(index + 64)

# Prints a list in format: [X1,X2,X3...Xn]
def printList(l):
    finalStr = "["
    for x in l:
        finalStr += str(x) + ", "

    if len(finalStr) > 1:
        finalStr = finalStr[0:len(finalStr) - 2]

    return finalStr + "]"

# Apparently python doesn't have a built in stack data structure so I made my own
# This is used for the undo funcion
class Stack():
	def __init__(stack):
	    stack.items = []
	
	def isEmpty(stack):
	    return stack.items == []
	
	def push(stack, item):
	    stack.items.insert(0,item)
	
	def pop(stack):
	    return stack.items.pop(0)
	
	def peek(stack):
	    return stack.items[0]
	
	def size(stack):
	    return len(stack.items)
     
def validateInput(positionInput, board, player, isOldPosition):
    # Validates input is correct format using RegEx and raises exceptions for different input errors

    match = re.match('[a-zA-Z]\d',positionInput);
    if not match:
        raise Exception("Please use format: [letter][number]")

    if letterToIndex(positionInput[0]) > 8 or letterToIndex(positionInput[0]) < 1 or int(positionInput[1]) < 0 or int(positionInput[1]) > 8:
        raise Exception("Invalid input. Letter must be from A to H and number must be from 1 to 8")

    if board.piecesArray[int(positionInput[1]) - 1][letterToIndex(positionInput[0]) - 1].player != player and board.piecesArray[int(positionInput[1]) - 1][letterToIndex(positionInput[0]) - 1].player != 0 and isOldPosition == True:
        raise Exception("Cannot move other player's piece!")

    if board.piecesArray[int(positionInput[1]) - 1][letterToIndex(positionInput[0]) - 1].marker == '-' and isOldPosition == True:
        raise Exception("There is no piece there!")

#     
# !!!! BELOW IS THE GAMEPLAY CODE !!!!
#

# Initial statements and name inputs
print("WELCOME TO PY-CHESS! Let's get started.")
print("Input player one name: ", end='')
player1Name = input()
print("Input player two name: ", end='')
player2Name = input()
print("\n\nLet's start the game!\nEnter 'q' at any time to quit.\n\n")

# creates instance of board with names
gameBoard = ChessBoard(player1Name, player2Name)

# default player number states
currentPlayer = 2
otherPlayer = 1

# continues until game is finished
while gameBoard.isFinished == False:

    # sets default new position state for while loop
    newPosition = 'X'

    if newPosition != 'NotCorrectYet':
        # adds current board state to the stack using a deep copy
        gameBoard.previousMoves.push(copy.deepcopy(gameBoard))

        # swaps between each player on each turn
        if currentPlayer == 1:
            currentPlayer = 2
            otherPlayer = 1
        else:
            currentPlayer = 1
            otherPlayer = 2

        # prints board state (set to one for now)
        print("Here is the current board:\n")
        gameBoard.printBoard(currentPlayer)

    

    # this loop will keep asking for an input until something other than X is inputted
    # this is so if the player decided they want to move a different piece they can
    while newPosition.upper() == 'X' or newPosition == 'NotCorrectYet':

        # sets default oldPosition for the undo while loop
        oldPosition = "U"

        # this loop will keep asking for an input until something other than U is inputted
        # this means the players can continually undo moves
        while oldPosition.upper() == 'U' or oldPosition == 'NotCorrectYet':

            # input for piece to be moved
            print("Enter the position of the piece you want to move? (Enter U to undo last move): ", end='')
            oldPosition = input() 

            if oldPosition == 'q':
                sys.exit("You quit the game!")

            if oldPosition != 'U':
                try:
                    validateInput(oldPosition, gameBoard, currentPlayer, True)
                except Exception as e:
                    print("Error: " + str(e))
                    oldPosition = 'NotCorrectYet'

            # if the user inputs \U for undo and this isn't the first move of the game
            if oldPosition == "U" and gameBoard.previousMoves.size() != 0:

                # utilizes a deep copy to retrieve the previous state of the board from the stack
                gameBoard = copy.deepcopy(gameBoard.previousMoves.pop().previousMoves.pop())
            
                print("Previous move undone!")

                # switch back to old player
                if currentPlayer == 1:
                    currentPlayer = 2
                    otherPlayer = 1
                else:
                    currentPlayer = 1
                    otherPlayer = 2

                # now print the current board state (set to one for now)
                print("Here is the current board:\n")
                gameBoard.printBoard(currentPlayer)


                
        # gets position of piece to be moved
        oldY = int(oldPosition[1]) - 1
        oldX = int(letterToIndex(oldPosition[0])) - 1

        # prints all possible moves of that piece
        print("\nYou can move that piece to: " + printList(gameBoard.piecesArray[oldY][oldX].generateMoveSet(oldPosition, gameBoard, False)))
        
        # input for new location
        print("\nWhere do you want to move it? (Input X to go back):", end='')
        newPosition = input()

        if newPosition == 'q':
                sys.exit("You quit the game!")
        
        try:
            # ensures first letter is capitalized
            firstChar = newPosition[0]
            firstChar = firstChar.upper()
            newPosition = firstChar + newPosition[1]
            validateInput(newPosition, gameBoard, currentPlayer, False)
        except Exception as e:
            print("\nError: " + str(e) + "\n")
            oldPosition = 'NotCorrectYet'
        else:
            # moves piece if there is no error
            try:
                gameBoard.playerMove(oldPosition, newPosition)
            except Exception as x:
                print("\nError: " + str(x) + "\n")
                newPosition = 'NotCorrectYet'

    print("\n")

    # looks to see if the other player is now in check
    check = gameBoard.isInCheck(otherPlayer, True)

    # prints check state
    if check == "CHECK":
        print('!!! YOU PUT THE OTHER PLAYER IN CHECK !!!')
    elif check == "CHECKMATE":
        gameBoard.printBoard(currentPlayer)
        print('!!! CHECKMATE. GAME OVER. !!!')